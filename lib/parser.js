// Generated by CoffeeScript 1.10.0
(function() {
  var checkValidLines, field_list, getOrder, hasNamedColumns, headings, lookup, parseNamed, parseTSV, ref, retailer_aliases, retailer_list, sanitize, stripQuotes;

  ref = require('./line_data'), retailer_list = ref.retailer_list, field_list = ref.field_list;

  retailer_aliases = {
    'Farnell': 'Farnell',
    'FEC': 'Farnell',
    'Premier': 'Farnell',
    'element14': 'Farnell',
    'Digi(-| )?key': 'Digikey',
    'Mouser': 'Mouser',
    'RS': 'RS',
    'RS(-| )?Online': 'RS',
    'RS(-| )?Delivers': 'RS',
    'Radio(-| )?Spares': 'RS',
    'RS(-| )?Components': 'RS',
    'Newark': 'Newark'
  };

  headings = {
    'refs?': 'reference',
    'references?': 'reference',
    'line(-| )?notes?': 'reference',
    'parts': 'reference',
    'comments?': 'description',
    'descriptions?': 'description',
    'cmnts?': 'description',
    'descrs?': 'description',
    'qn?tys?': 'quantity',
    'quantity': 'quantity',
    'quantities': 'quantity',
    'quant.?': 'quantity',
    'part(-| )?numbers?': 'partNumber',
    'm/?f parts?': 'partNumber',
    'manuf\\.? parts?': 'partNumber',
    'mpns?': 'partNumber',
    'm/?f part numbers?': 'partNumber',
    'manuf\\.? part numbers?': 'partNumber',
    'manufacturer parts?': 'partNumber',
    'manufacturer part numbers?': 'partNumber',
    'prts?': 'partNumber',
    'manuf#': 'partNumber',
    'manufacturers?': 'manufacturer',
    'm/?f': 'manufacturer',
    'manuf\\.?': 'manufacturer'
  };

  lookup = function(name, obj) {
    var key, re;
    for (key in obj) {
      re = RegExp(key, 'i');
      if (name.match(re)) {
        return obj[key];
      }
    }
    return null;
  };

  stripQuotes = function(str) {
    var last, ret;
    ret = str;
    if (ret[0] === '"' || ret[0] === "'") {
      ret = ret.substr(1);
    }
    last = ret.length - 1;
    if (ret[last] === '"' || ret[last] === "'") {
      ret = ret.substr(0, last);
    }
    return ret;
  };

  sanitize = function(str) {
    if (!str) {
      return '';
    }
    return stripQuotes(str).trim();
  };

  checkValidLines = function(lines_incoming, invalid, warnings) {
    var field, j, key, len, len1, line, lines, m, number, ref1, v;
    lines = [];
    for (j = 0, len = lines_incoming.length; j < len; j++) {
      line = lines_incoming[j];
      if (invalid.length > 10) {
        lines = [];
        break;
      }
      number = parseInt(line.quantity);
      if (isNaN(number)) {
        invalid.push({
          row: line.row,
          reason: 'Quantity is not a number.'
        });
      } else if (number < 1) {
        invalid.push({
          row: line.row,
          reason: 'Quantity is less than one.'
        });
      } else {
        line.quantity = number;
        ref1 = line.retailers;
        for (key in ref1) {
          v = ref1[key];
          if (v == null) {
            line.retailers[key] = '';
          } else if (key !== 'Digikey') {
            line.retailers[key] = v.replace(/-/g, '');
          }
        }
        for (m = 0, len1 = field_list.length; m < len1; m++) {
          field = field_list[m];
          if (line[field] == null) {
            line[field] = '';
          }
        }
        lines.push(line);
      }
    }
    return {
      lines: lines,
      invalid: invalid,
      warnings: warnings
    };
  };

  parseNamed = function(rows, order, retailers) {
    var cells, index, invalid, j, len, line, lines, parts, row, rs;
    lines = [];
    invalid = [];
    for (index = j = 0, len = rows.length; j < len; index = ++j) {
      row = rows[index];
      console.log(index);
      if (row !== '') {
        cells = row.split('\t');
        rs = function() {
          var len1, len2, m, n, r, retailersObj;
          retailersObj = {};
          for (m = 0, len1 = retailer_list.length; m < len1; m++) {
            r = retailer_list[m];
            retailersObj[r] = '';
          }
          for (n = 0, len2 = retailers.length; n < len2; n++) {
            r = retailers[n];
            if (cells[order.indexOf(r)] != null) {
              retailersObj["" + r] = sanitize(cells[order.indexOf(r)]);
            }
          }
          return retailersObj;
        };
        parts = function() {
          var field, i, len1, len2, len3, m, manuf, manuf_index, manuf_indexes, n, o, part, part_index, part_indexes, part_list;
          part_list = [];
          part_indexes = [];
          manuf_indexes = [];
          for (i = m = 0, len1 = order.length; m < len1; i = ++m) {
            field = order[i];
            if (field === 'partNumber') {
              part_indexes.push(i);
            }
          }
          for (i = n = 0, len2 = order.length; n < len2; i = ++n) {
            field = order[i];
            if (field === 'manufacturer') {
              manuf_indexes.push(i);
            }
          }
          for (i = o = 0, len3 = part_indexes.length; o < len3; i = ++o) {
            part_index = part_indexes[i];
            try {
              manuf_index = manuf_indexes[i];
            } catch (undefined) {}
            if (manuf_index != null) {
              manuf = sanitize(cells[manuf_index]);
            } else {
              manuf = '';
            }
            part = sanitize(cells[part_index]);
            if ((part != null) && part !== '') {
              part_list.push({
                part: part,
                manufacturer: manuf
              });
            }
          }
          return part_list;
        };
        line = {
          reference: sanitize(cells[order.indexOf('reference')]),
          quantity: sanitize(cells[order.indexOf('quantity')]),
          description: sanitize(cells[order.indexOf('description')]),
          partNumbers: parts(),
          retailers: rs(),
          row: index + 1
        };
        if ((line.reference == null) || line.reference === '') {
          invalid.push({
            row: line.row,
            reason: 'Reference is undefined.'
          });
        } else if (line.quantity == null) {
          invalid.push({
            row: line.row,
            reason: 'Quantity is undefined.'
          });
        } else {
          lines.push(line);
        }
      }
    }
    return {
      lines: lines,
      invalid: invalid
    };
  };

  hasNamedColumns = function(cells) {
    var cell, j, len;
    for (j = 0, len = cells.length; j < len; j++) {
      cell = cells[j];
      if (lookup(cell, headings) != null) {
        return true;
      }
    }
    return false;
  };

  getOrder = function(cells) {
    var cell, heading, j, k, len, order, possible_names, retailer, retailers, v, warnings;
    order = [];
    retailers = [];
    warnings = [];
    possible_names = {};
    for (k in headings) {
      v = headings[k];
      possible_names[k] = v;
    }
    for (k in retailer_aliases) {
      v = retailer_aliases[k];
      possible_names[k] = v;
    }
    for (j = 0, len = cells.length; j < len; j++) {
      cell = cells[j];
      if (cell === '') {
        order.push('');
      } else {
        heading = lookup(cell, possible_names);
        retailer = lookup(cell, retailer_aliases);
        if (retailer != null) {
          retailers.push(retailer);
        }
        if (heading != null) {
          order.push(heading);
        } else {
          warnings.push({
            title: "Unknown column-heading '" + cell + "'",
            message: "Column " + (order.length + 1) + " was ignored."
          });
          order.push('');
        }
      }
    }
    return {
      order: order,
      retailers: retailers,
      warnings: warnings
    };
  };

  parseTSV = function(text) {
    var firstCells, invalid, l, lines, order, reason, ref1, ref2, ref3, retailers, rows, warnings;
    rows = text.split('\n');
    firstCells = rows[0].split('\t');
    warnings = [];
    l = firstCells.length;
    if (l < 2) {
      return {
        lines: [],
        invalid: [
          {
            row: 1,
            reason: "The data doesn't look like tab separated values."
          }
        ]
      };
    } else if (l < 3) {
      return {
        lines: [],
        invalid: [
          {
            row: 1,
            reason: "Only " + l + " column" + (l > 1 ? 's' : '') + ". At least 3 are required."
          }
        ]
      };
    }
    if (hasNamedColumns(firstCells)) {
      ref1 = getOrder(firstCells), order = ref1.order, retailers = ref1.retailers, reason = ref1.reason, warnings = ref1.warnings;
      if (!((order != null) && (retailers != null))) {
        return {
          lines: [],
          invalid: [
            {
              row: 1,
              reason: reason
            }
          ]
        };
      }
      if (order.indexOf('reference') < 0) {
        return {
          lines: [],
          invalid: [
            {
              row: 1,
              reason: 'You need a references column.'
            }
          ]
        };
      }
      ref2 = parseNamed(rows.slice(1), order, retailers), lines = ref2.lines, invalid = ref2.invalid;
    } else {
      warnings.push({
        title: "You have input data in the legacy format!",
        message: "This format has been disabled please tell us if you do rely on it."
      });
    }
    ref3 = checkValidLines(lines, invalid, warnings), lines = ref3.lines, invalid = ref3.invalid, warnings = ref3.warnings;
    return {
      lines: lines,
      invalid: invalid,
      warnings: warnings
    };
  };

  exports.parseTSV = parseTSV;

  exports.stripQuotes = stripQuotes;

}).call(this);

//# sourceMappingURL=parser.js.map
