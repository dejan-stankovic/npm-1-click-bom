// Generated by CoffeeScript 1.10.0
(function() {
  var checkValidLines, field_list, getOrder, hasNamedColumns, headings, lookup, parseNamed, parseSimple, parseTSV, ref, retailer_aliases, retailer_list;

  ref = require('./line_data'), retailer_list = ref.retailer_list, field_list = ref.field_list;

  retailer_aliases = {
    'Farnell': 'Farnell',
    'FEC': 'Farnell',
    'Premier': 'Farnell',
    'element14': 'Farnell',
    'Digi(-| )?key': 'Digikey',
    'Mouser': 'Mouser',
    'RS': 'RS',
    'RS(-| )?Online': 'RS',
    'RS(-| )?Delivers': 'RS',
    'Radio(-| )?Spares': 'RS',
    'RS(-| )?Components': 'RS',
    'Newark': 'Newark'
  };

  headings = {
    'refs?': 'reference',
    'references?': 'reference',
    'line(-| )?notes?': 'reference',
    'comments?': 'description',
    'descriptions?': 'description',
    'cmnts?': 'description',
    'descrs?': 'description',
    'qtys?': 'quantity',
    'quantity': 'quantity',
    'quantities': 'quantity',
    'part(-| )?numbers?': 'partNumber',
    'm/?f parts?': 'partNumber',
    'manuf\\.? parts?': 'partNumber',
    'mpns?': 'partNumber',
    'm/?f part numbers?': 'partNumber',
    'manuf\\.? part numbers?': 'partNumber',
    'manufacturer parts?': 'partNumber',
    'manufacturer part numbers?': 'partNumber',
    'prts?': 'partNumber',
    'parts?': 'partNumber'
  };

  lookup = function(name, obj) {
    var key, re;
    for (key in obj) {
      re = RegExp(key, 'i');
      if (name.match(re)) {
        return obj[key];
      }
    }
    return null;
  };

  checkValidLines = function(lines_incoming, invalid, warnings) {
    var field, j, key, len, len1, line, lines, m, number, ref1, v;
    lines = [];
    for (j = 0, len = lines_incoming.length; j < len; j++) {
      line = lines_incoming[j];
      if (invalid.length > 10) {
        lines = [];
        break;
      }
      number = parseInt(line.quantity);
      if (isNaN(number)) {
        invalid.push({
          row: line.row,
          reason: 'Quantity is not a number.'
        });
      } else if (number < 1) {
        invalid.push({
          row: line.row,
          reason: 'Quantity is less than one.'
        });
      } else {
        line.quantity = number;
        ref1 = line.retailers;
        for (key in ref1) {
          v = ref1[key];
          if (v == null) {
            line.retailers[key] = '';
          } else if (key !== 'Digikey') {
            line.retailers[key] = v.replace(/-/g, '');
          }
        }
        for (m = 0, len1 = field_list.length; m < len1; m++) {
          field = field_list[m];
          if (line[field] == null) {
            line[field] = '';
          }
        }
        lines.push(line);
      }
    }
    return {
      lines: lines,
      invalid: invalid,
      warnings: warnings
    };
  };

  parseSimple = function(rows) {
    var cells, i, invalid, j, len, len1, line, lines, m, r, retailer, retailersObj, row;
    lines = [];
    invalid = [];
    for (i = j = 0, len = rows.length; j < len; i = ++j) {
      row = rows[i];
      if (row !== '') {
        cells = row.split('\t');
        retailer = lookup(cells[2], retailer_aliases);
        if (!retailer) {
          if (cells[2] === '') {
            invalid.push({
              row: i + 1,
              reason: "Retailer is not defined."
            });
          } else {
            invalid.push({
              row: i + 1,
              reason: "Retailer '" + cells[2] + "' is not known."
            });
          }
        } else {
          retailersObj = {};
          for (m = 0, len1 = retailer_list.length; m < len1; m++) {
            r = retailer_list[m];
            retailersObj[r] = '';
          }
          retailersObj["" + retailer] = cells[3];
          line = {
            reference: cells[0],
            quantity: cells[1],
            retailers: retailersObj,
            row: i + 1
          };
          if (!line.quantity) {
            invalid.push({
              row: line.row,
              reason: 'Quantity is undefined.'
            });
          } else if (!line.retailers["" + retailer]) {
            invalid.push({
              row: line.row,
              reason: 'Part number is undefined.'
            });
          } else {
            lines.push(line);
          }
        }
      }
    }
    return {
      lines: lines,
      invalid: invalid
    };
  };

  parseNamed = function(rows, order, retailers) {
    var cells, i, invalid, j, len, line, lines, parts, ref1, ref2, ref3, row, rs;
    lines = [];
    invalid = [];
    for (i = j = 0, len = rows.length; j < len; i = ++j) {
      row = rows[i];
      if (row !== '') {
        cells = row.split('\t');
        rs = function() {
          var len1, len2, m, n, r, retailersObj;
          retailersObj = {};
          for (m = 0, len1 = retailer_list.length; m < len1; m++) {
            r = retailer_list[m];
            retailersObj[r] = '';
          }
          for (n = 0, len2 = retailers.length; n < len2; n++) {
            r = retailers[n];
            if (cells[order.indexOf(r)] != null) {
              retailersObj["" + r] = cells[order.indexOf(r)].trim();
            }
          }
          return retailersObj;
        };
        parts = function() {
          var field, index, len1, len2, m, n, part, part_indexes, part_list;
          part_list = [];
          part_indexes = [];
          for (i = m = 0, len1 = order.length; m < len1; i = ++m) {
            field = order[i];
            if (field === 'partNumber') {
              part_indexes.push(i);
            }
          }
          for (n = 0, len2 = part_indexes.length; n < len2; n++) {
            index = part_indexes[n];
            part = cells[index];
            if (part !== '') {
              part_list.push(part);
            }
          }
          return part_list;
        };
        line = {
          reference: (ref1 = cells[order.indexOf('reference')]) != null ? ref1.trim() : void 0,
          quantity: (ref2 = cells[order.indexOf('quantity')]) != null ? ref2.trim() : void 0,
          description: (ref3 = cells[order.indexOf('description')]) != null ? ref3.trim() : void 0,
          partNumbers: parts(),
          retailers: rs(),
          row: i + 1
        };
        if ((line.reference == null) || line.reference === '') {
          invalid.push({
            row: line.row,
            reason: 'Reference is undefined.'
          });
        } else if (line.quantity == null) {
          invalid.push({
            row: line.row,
            reason: 'Quantity is undefined.'
          });
        } else {
          lines.push(line);
        }
      }
    }
    return {
      lines: lines,
      invalid: invalid
    };
  };

  hasNamedColumns = function(cells) {
    var cell, j, len;
    for (j = 0, len = cells.length; j < len; j++) {
      cell = cells[j];
      if (lookup(cell, headings) != null) {
        return true;
      }
    }
    return false;
  };

  getOrder = function(cells) {
    var cell, heading, j, k, len, order, possible_names, retailer, retailers, v, warnings;
    order = [];
    retailers = [];
    warnings = [];
    possible_names = {};
    for (k in headings) {
      v = headings[k];
      possible_names[k] = v;
    }
    for (k in retailer_aliases) {
      v = retailer_aliases[k];
      possible_names[k] = v;
    }
    for (j = 0, len = cells.length; j < len; j++) {
      cell = cells[j];
      if (cell === '') {
        order.push('');
      } else {
        heading = lookup(cell, possible_names);
        retailer = lookup(cell, retailer_aliases);
        if (retailer != null) {
          retailers.push(retailer);
        }
        if (heading != null) {
          order.push(heading);
        } else {
          warnings.push({
            title: "Unknown column-heading '" + cell + "'",
            message: "Column " + (order.length + 1) + " was ignored."
          });
          order.push('');
        }
      }
    }
    return {
      order: order,
      retailers: retailers,
      warnings: warnings
    };
  };

  parseTSV = function(text) {
    var firstCells, invalid, l, lines, order, reason, ref1, ref2, ref3, ref4, retailers, rows, warnings;
    rows = text.split('\n');
    firstCells = rows[0].split('\t');
    warnings = [];
    l = firstCells.length;
    if (l < 2) {
      return {
        lines: [],
        invalid: [
          {
            row: 1,
            reason: "The data doesn't look like tab separated values."
          }
        ]
      };
    } else if (l < 3) {
      return {
        lines: [],
        invalid: [
          {
            row: 1,
            reason: "Only " + l + " column" + (l > 1 ? 's' : '') + ". At least 3 are required."
          }
        ]
      };
    }
    if (hasNamedColumns(firstCells)) {
      ref1 = getOrder(firstCells), order = ref1.order, retailers = ref1.retailers, reason = ref1.reason, warnings = ref1.warnings;
      if (!((order != null) && (retailers != null))) {
        return {
          lines: [],
          invalid: [
            {
              row: 1,
              reason: reason
            }
          ]
        };
      }
      if (order.indexOf('reference') < 0) {
        return {
          lines: [],
          invalid: [
            {
              row: 1,
              reason: 'You need a references column.'
            }
          ]
        };
      }
      ref2 = parseNamed(rows.slice(1), order, retailers), lines = ref2.lines, invalid = ref2.invalid;
    } else {
      ref3 = parseSimple(rows), lines = ref3.lines, invalid = ref3.invalid;
      warnings.push({
        title: "You have input data in the legacy format!",
        message: "This format will be phased out by version 1.0. Please inform us if you rely on it."
      });
    }
    ref4 = checkValidLines(lines, invalid, warnings), lines = ref4.lines, invalid = ref4.invalid, warnings = ref4.warnings;
    return {
      lines: lines,
      invalid: invalid,
      warnings: warnings
    };
  };

  exports.parseTSV = parseTSV;

}).call(this);

//# sourceMappingURL=parser.js.map
