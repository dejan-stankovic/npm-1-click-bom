// Generated by CoffeeScript 1.10.0
(function() {
  var retailer_list,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  retailer_list = ['Digikey', 'Mouser', 'RS', 'Newark', 'Farnell'];

  exports.retailer_list = retailer_list;

  exports.field_list = ['partNumbers', 'description'];

  exports.isComplete = function(lines) {
    var complete, i, j, len, len1, line, r, ref1;
    complete = true;
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      ref1 = exports.retailer_list;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        r = ref1[j];
        if (line.retailers[r] === '') {
          complete = false;
          break;
        }
      }
      if (line.partNumbers.length < 1) {
        complete = false;
      }
      if (!complete) {
        break;
      }
    }
    return complete;
  };

  exports.hasSKUs = function(lines) {
    var hasSKUs, i, j, len, len1, line, r, ref1;
    hasSKUs = false;
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      ref1 = exports.retailer_list;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        r = ref1[j];
        if (line.retailers[r] !== '') {
          hasSKUs = true;
          break;
        }
      }
      if (hasSKUs) {
        break;
      }
    }
    return hasSKUs;
  };

  exports.numberOfEmpty = function(lines) {
    var i, j, len, len1, line, n, r, ref1;
    n = 0;
    for (i = 0, len = lines.length; i < len; i++) {
      line = lines[i];
      if (line.partNumbers.length < 1) {
        n += 1;
      }
      ref1 = exports.retailer_list;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        r = ref1[j];
        if (line.retailers[r] === '') {
          n += 1;
        }
      }
    }
    return n;
  };

  exports.merge = function(lines1, lines2) {
    var d, duplicates, exists, has_new_parts, i, index, index_, j, k, l, len, len1, len2, len3, len4, line1, line2, line2_, m, merged, n, part2, r, ref, ref1, warnings;
    warnings = [];
    duplicates = {};
    merged = lines1;
    for (index = i = 0, len = lines2.length; i < len; index = ++i) {
      line2 = lines2[index];
      for (index_ = j = 0, len1 = lines2.length; j < len1; index_ = ++j) {
        line2_ = lines2[index_];
        if (index !== index_ && line2.reference === line2_.reference) {
          d = duplicates[line2.reference];
          if (d != null) {
            if (indexOf.call(d, index) < 0) {
              d.push(index);
            }
            if (indexOf.call(d, index_) < 0) {
              d.push(index_);
            }
          } else {
            duplicates[line2.reference] = [index, index_];
          }
        }
      }
      exists = false;
      for (k = 0, len2 = merged.length; k < len2; k++) {
        line1 = merged[k];
        if (line1.reference === line2.reference) {
          exists = true;
          has_new_parts = false;
          for (l = 0, len3 = retailer_list.length; l < len3; l++) {
            r = retailer_list[l];
            if (line2.retailers[r] !== '') {
              if (line1.retailers[r] !== line2.retailers[r]) {
                has_new_parts = true;
              }
              line1.retailers[r] = line2.retailers[r];
            }
          }
          ref1 = line2.partNumbers;
          for (m = 0, len4 = ref1.length; m < len4; m++) {
            part2 = ref1[m];
            has_new_parts = !line1.partNumbers.reduce(function(prev, part1) {
              return prev || (part1.part === part2.part) && (part1.manufacturer === part2.manufacturer);
            }, false);
            if (has_new_parts) {
              line1.partNumbers.push(part2);
            }
          }
          if (!has_new_parts) {
            line1.quantity += line2.quantity;
          }
          break;
        }
      }
      if (!exists) {
        merged.push(line2);
      }
    }
    for (ref in duplicates) {
      d = duplicates[ref];
      warnings.push({
        title: 'Duplicate lines detected',
        message: "You have the exact same reference '" + ref + "' on lines " + ((function() {
          var len5, o, ref2, results;
          ref2 = d.slice(0, +(d.length - 2) + 1 || 9e9);
          results = [];
          for (o = 0, len5 = ref2.length; o < len5; o++) {
            n = ref2[o];
            results.push(n + 1);
          }
          return results;
        })()) + " and " + (d[d.length - 1] + 1) + ". These have been merged"
      });
    }
    return [merged, warnings];
  };

}).call(this);

//# sourceMappingURL=line_data.js.map
